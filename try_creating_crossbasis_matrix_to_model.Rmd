---
title: "try creating crossbasis matrix to model"
author: "Meilin Yan"
date: "December 24, 2016"
output: word_document
---

```{r include=FALSE}
library(lubridate)
library(dplyr)
library(dlnm)
library(splines)

readCity <- function(city = c(), collapseAge = TRUE){
  root <- "~/tmp/NMMAPS/"
  file <- paste(root, city, ".rds", sep = "")
  df <- readRDS(file)

  if(collapseAge == TRUE){
    df <- rowsum(df[,c("alldeath", "death", "accident", "cvd", "resp",
                       "copd", "suicide", "tmpd", "dptp")], df$date,
                 reorder = FALSE)
    df$date <- as.Date(rownames(df))
    df[ , c("tmpd", "dptp")] <- df[ , c("tmpd", "dptp")]/3
    df$dow <- as.factor(as.POSIXlt(df$date)$wday)
  }
  
  return(df)
}

readStorm <- function(criterion = c(), city = c()){
  root <- "exposure/"
  file <- paste(root, criterion, "/", city, ".rds", sep = "")
  df <- readRDS(file)
  df <- as.data.frame(df)
  df$date <- lubridate::ymd(df$closest_date)
  
  return(df)
}

city.storm <- function(criterion = c(), city = c()){
  # Get health data
  h.df <- readCity(city)
  # Get storm data
  s.df <- readStorm(criterion, city)
  
  storm_days <- s.df$date
  
  df <- left_join(h.df, s.df, by = "date") %>%
        mutate(hurr = ifelse(date %in% storm_days, 1, 0))
  df$hurr <- as.factor(df$hurr)
  
  # Add abbreviate and full cityname
  df$city <- city
  sub.county <- readRDS("data/sub.county.rds")
     
  cityname <- sub.county$citynameU[sub.county$city == city]
  df$cityname <- cityname
  
  #df$time <- scale(as.numeric(df$date), center = TRUE, scale = FALSE)
  #n.years <- length(unique(as.POSIXlt(df$date)$year))
  df$year <- year(df$date)
  df$doy <- yday(df$date)
  
  # Total death
  df$all <- df$accident + df$death
  
  return(df)
}
```

If I did the following steps,

\
1.Obtain matrix from **crossbasis** function by using the orignal data;
\
2.Generate a new data set with "controls days" for each storm;
\
3.Extract **matrix used for model** by matching the matrix in **1** to the new data set in **2**.


\
Then I came across a problem, the **crosspred** function didn't work with **matrix used for model** and the new data set.
\
(error "arguments 'basis' and 'model' not consistent. See help(crosspred)"). 

\
Because the **matrix used for model** from **3** is just **matrix**, not **crossbasis** class. The **crosspred** function also needs the attributes of **crossbasis** class for calculation. So I revised the steps as,
\
1.Generate a new data set with "control days" for each storm;
\
2.Obtain **matrix (also the matrix used for model)** from **crossbasis** function by using the new data set.


#### City with 4 storms

```{r warning=FALSE, message=FALSE, cache=TRUE}
df <- city.storm(criterion = "rain125", city = "miam") # 4 storms: 2877, 3157, 4671, 5026 (row number)
```


```{r warning=FALSE, message=FALSE, fig.width=6, fig.height=4}
## Find 14 lag days for each storm (1-14 days following storm day)
## Generate control days for each storm
df$time <- 1:length(df$hurr)
cand_control <- unique(c(which(df$hurr == 1) , which(df$hurr == 1) + 1,
                         which(df$hurr == 1) - 1))
df$cand_control <- TRUE
df$cand_control[cand_control] <- FALSE

case_dates <- subset(df, hurr == 1) # hurr is exposure
control_dates <- subset(df, hurr == 0)

control_ratio <- 15
lags <- 14

for(i in 1:nrow(case_dates)){
  ## choose lags of storm days (lag0)
  lag_dates <- case_dates[i, ]$date + 1:lags
  lag_case <- subset(df, date %in% lag_dates)
  
  ## choose controls for storm days (lag0)
  control_range <- case_dates[i, ]$doy + -3:3 
  control_subset <- subset(control_dates, 
                           control_dates$year != case_dates[i, ]$year &
                           doy %in% control_range & 
                           cand_control) 
  controls <- sample_n(control_subset, control_ratio)
  
  ## lagged controls
  for(j in 1:lags){
    lag_control_dates <- controls$date + j
    lag_control_each <- subset(df, date %in% lag_control_dates)
    
    if(j == 1){
      lag_control <- lag_control_each
    }else{
      lag_control <- rbind(lag_control, lag_control_each)
    }
  }
  
  i_stratum <- rbind(case_dates[i, ], lag_case, controls, lag_control)
  
  stratum <- paste("stratum", i, sep = ".")
  i_stratum$stratum <- stratum
  
  status <- c(rep("case", lags + 1), rep("control", control_ratio*(lags + 1))) # case: 1 storm day + 14 lagged day
  i_stratum$status <- status
  
  lag <- c(0:lags, rep(0:lags, each = control_ratio))
  i_stratum$lag <- lag
  
  if(i == 1){
    new_df <- i_stratum
  }else{
     new_df <- rbind(new_df, i_stratum)
     }
  }

# new_df <- new_df %>% arrange(stratum, lag)

nrow(new_df) # 960
length(unique(new_df$date)) # could be less than or equal to 960 for possible duplicated controls

# Take a look of the new data set 
# Just show a few variable in order to show the core information
head(new_df[, c("hurr", "time", "date", "cand_control", "stratum", "status", "lag")], 280)

# Modify the new data set for crossbasis
## rbind a "fake" data frame with 14 rows (lag = 14) and same number of columns to "new_df"
## Because "crossbasis" will set the first 14 rows as NA

coln <- ncol(new_df)
be_data <- as.data.frame(matrix(0, nrow = lags, ncol = coln))
colnames(be_data) <- colnames(new_df)
df_to_mod <- rbind(be_data, new_df)

head(df_to_mod[, c("hurr", "time", "date", "cand_control", "stratum", "status", "lag")], 50)

# crossbasis
cb <- crossbasis(df_to_mod$hurr, lag = c(0, lags), 
                 argvar = list(fun = "lin"),
                 arglag = list(fun = "ns", knots = c(1, 4, 8)))
head(cb, 280)

mod <- glm(all ~ cb + ns(year, 2) + stratum, 
            family = quasipoisson(link = log), data = df_to_mod,
            control = glm.control(epsilon = 10E-8, maxit = 5000))

pred <- crosspred(cb, mod, at = 1)
plot(pred, "slices", var = 1, ylab = "RR")
```
